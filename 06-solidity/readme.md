# solidity


Chaineye  面试题汇集，供想要学习的小伙伴学习。

推特：@seek_web3

Chainey 社群： 官网 chaineye.info | Chaineye Rust 教程 | 微信: LGZAXE, 加微信之后拉各社群 

所有代码和教程开源在github: https://github.com/0xchaineye/chaineye-blockchain-interview

----------------------------------------------------------------------------------------------------------------------------------------------------------


## 1. 在实际生产中，如果想要保证测试网和主网的合约地址一致，应当怎么做

合约地址是由 nonce 和 address 决定的，所以只要保证 nonce 和 address 一样即可.

## 2.solidity智能合约的 pure 与 view 使用原理及场景

### pure 与 view 原理

pure：不读取更不修改区块上的变量，使用本机的CPU资源计算我们的函数。所以不消耗任何的资源这是很容易的理解的。

view: 但是 view 既然要读取区块链上的值，为什么也不用消耗 gas 呢？

其实很简单，因为作为一个全节点来说，会同步保存所有的信息，保存在本地中。

那么我们要查看区块链上的资源，同样可以直接在一个全节点之上查询数据即可。

我不需要全世界的节点都知道。都去同时的处理这笔事务。我也不需要将调用这笔函数的信息记录在区块链上。

所以 view 仍然不消耗 gas。

view: 可以自由调用，因为它只是“查看”区块链的状态而不改变它

pure: 也可以自由调用，既不读取也不写入区块链


## 3. 如何将固定字节数组转动态字节数组

要将固定长度的字节数组转换为动态长度的字节数组，需要首先创建动态数组，并挨个赋值。

```
pragma solidity ^0.4.23;

contract  fixTodynamic{
      bytes6 name =  0x6a6f6e736f6e;

    function  Todynamic() view public returns(bytes){
        //return bytes(name);
        bytes memory newName = new bytes(name.length);

        //for循环挨个赋值
        for(uint i = 0;i<name.length;i++){
           newName[i] =  name[i];
        }
        return newName;
    }
}
```

### 3. 简单说明智能合约的构造函数和初始化函数的特性与区别

构造函数是特殊的函数，在部署合约的时候，就会被调用。而且只能够在此时被调用。常常用于对于某一些状态变量的初始化。
初始化函数是对对合约进行初始化，只能被调用一层

### 4. 在 Solidity 中，public、private、internal 和 external 都是用来控制合约中函数和变量的访问级别和可见性的关键字。

- public
public 是 Solidity 中默认的访问级别修饰符，表示该函数或变量对所有人可见和可调用。在合约内部或外部都可以访问和调用。使用 public 修饰的函数或变量，会自动生成一个公共的 getter 函数，用于获取变量的值。

- private
private 是 Solidity 中用来限制函数或变量只能在当前合约内部访问的修饰符。使用 private 修饰的函数或变量，不能被合约外部的其他合约或者外部账户访问或调用。

- internal
internal 是 Solidity 中用来限制函数或变量只能在当前合约和其子合约内部访问的修饰符。使用 internal 修饰的函数或变量，不能被合约外部的其他合约或者外部账户访问或调用。

- external
external 是 Solidity 中用来限制函数只能被合约外部的账户访问和调用的修饰符。使用 external 修饰的函数，不能在合约内部被访问和调用，只能在合约外部被调用。


### 4. 智能合约合约继承与可见性

继承是面向对象语言的重要特征。继承是为了模拟现实中的现象，并且可以简化代码的书写。例如猫与够都属于动物。他们都继承动物的某些特征。
合约的继承语法

```
contract  合约名  is  父类合约名{

}
```

- 继承与可见性

状态变量默认是public的类型，可以被继承，可以在外部与内部被调用, 函数默认为public属性,可以被继承，可以在外部与内部被调用

internal: 当为状态变量添加了inernal属性，仍然可以被继承，internal属性只能够被合约中的方法调用，不能够在外部被直接调用。当为函数添加了inernal属性，仍然可以被继承，internal属性只能够被合约中的方法调用，不能够在外部被直接调用。

external: 状态变量没有external属性，但是函数有。当为函数加上external属性后，意味着合约只能够在外部被调用，不能够在内部被调用。不能被继承。



### 5. 简单说明 solidity 中 storage、memory 和 calldata 区别与联系

存储位置：storage 和 memory 都是用于存储数据的位置，而 calldata 只是用于在函数调用中传递数据的位置。

生命周期：storage 中的变量在函数调用结束后仍然存在于合约存储器中，而 memory 中的变量在函数调用结束时被删除，calldata 中的数据也在函数调用结束时被删除。

访问：storage 和 memory 中的变量可以进行读取和写入操作，而calldata中的数据只能读取，不能修改。

费用：使用 storage 操作 比memory 更昂贵，因为它需要写入永久存储器，并且会产生永久的状态更改。而 memory 操作相对便宜，因为它只是在临时存储器中分配和读取数据。对于calldata，只能读取，不需要支付任何费用。

类型：在 storage 和 memory 中，可以存储任何 Solidity 类型的数据，包括结构体和数组。但是，在calldata中，只能传递固定大小的原始类型数据。

总体来说，storage 和 memory 用于存储变量，而 calldata 用于传递函数参数。存储位置、生命周期、访问和费用等方面的差异决定了它们在使用中的不同。


### 6. 你是用过哪些种类的合约升级方式，你是怎么操作他们的，升级过程中需要注意哪些事项？

创建新合约并迁移数据：这种方法需要编写新的合约代码，并将旧合约中的数据迁移到新合约中。这种方式需要确保数据的正确迁移，并且需要将旧合约地址作为参数传递给新合约，以便其他合约和用户可以找到新合约。

使用库合约：这种方式可以通过将合约的逻辑与数据分离来进行升级。新的逻辑可以放在一个新的库合约中，并且可以将新的库合约地址设置为旧合约的一个新变量。这样，新逻辑就可以被调用，而数据不需要迁移。

使用代理合约：这种方式也称为升级合约模式。旧合约被称为代理合约，它只包含一些基本的逻辑，如转发交易和调用新合约。新合约则包含更复杂的逻辑。在这种方式中，所有交易都被发送到代理合约，代理合约再将交易转发到新合约进行处理。

在进行合约升级之前，需要确保在升级过程中没有数据丢失或不一致，并且需要考虑安全性问题。操作时需要注意确保权限控制，保护用户资产等安全措施，避免出现意外或者恶意的操作。建议在开发和测试环境中进行合约升级的实验，并使用多重签名等方式确保升级操作的安全性。

升级过程中需要注意 public 变量的存放 slot 位置，，否则会导致数据错乱。


### 7. 常见的智能合约审计工具有哪些，并说明他们之间的区别

智能合约审计工具是一种用于检查智能合约代码安全性和漏洞的软件工具。以下是几种常见的智能合约审计工具：

- Mythril：Mythril是一款基于Python的开源工具，主要用于发现智能合约中可能存在的漏洞。Mythril采用了静态分析的方法，通过对代码的静态扫描来检测漏洞。Mythril支持多种以太坊虚拟机（EVM）及其他区块链的智能合约。

- Oyente：Oyente是一款基于Python的开源工具，用于检查智能合约中可能存在的漏洞。Oyente采用了静态分析的方法，可以检测重入、交易依赖性、迭代器错误等漏洞。

- Securify：Securify是一种基于静态分析的工具，用于检查以太坊智能合约中的漏洞和缺陷。

- SmartCheck：SmartCheck是一款智能合约静态分析和漏洞检测工具，旨在提高智能合约的安全性和可靠性。SmartCheck支持多种虚拟机和智能合约语言，包括Solidity、Vyper、Bamboo等。

- Slither：Slither是一款开源工具，可帮助开发人员和审计人员检测和解决智能合约中的漏洞。Slither采用了静态分析的方法，支持多种虚拟机，可以检测重入、状态可变性、溢出等漏洞。

- Manticore：Manticore是一种动态二进制分析工具，可用于分析以太坊智能合约中的漏洞和安全性。

- Echidna：Echidna是一种基于符号执行的工具，可用于检查以太坊智能合约中的漏洞和安全性。

- Teether：Teether是一个基于二进制分析的工具，用于检查以太坊智能合约的漏洞和缺陷。

以上是一些常见的智能合约审计工具，这些工具可以帮助开发人员和审计人员发现并修复智能合约中的安全漏洞和缺陷。

### 8. 合约攻击相关的

参考教程: [点击查看](https://www.wenwoha.com/17/course_detail)

### 9. 你知道的合约集成编译工具有哪些，并简要说明他们的区别？

hardhat, foundry, remix和truffle

Hardhat：是一个基于 Node.js 的开发环境，提供了丰富的插件和功能，支持编写、测试和部署以太坊智能合约。它还支持与其他工具的集成，如 Remix 和 Truffle。

Foundry：是一个开发人员平台，用于构建、部署和管理以太坊智能合约。Foundry 提供了一种简单的方法来编写智能合约并将其部署到以太坊网络上。

Remix：是一个基于 Web 的 IDE，用于编写、测试和部署以太坊智能合约。它提供了一个直观的用户界面，可以轻松地创建、编辑和调试智能合约。

Truffle：是一个基于 Node.js 的开发框架，提供了一组工具和库，用于编写、测试和部署以太坊智能合约。Truffle 还提供了一个交互式控制台，可以与以太坊网络进行交互，以及支持与其他工具的集成，如 Ganache。

### 10. 简要说明 ERC721 和 ERC 1155 的区别

ERC721和ERC1155都是以太坊上的智能合约标准，用于定义不同类型的数字资产和代币。ERC721标准最初用于定义不可替代代币（Non-Fungible Token，NFT），而ERC1155标准则用于定义可替代和不可替代代币。

ERC721代币是唯一的、不可替代的，每个代币都有其自己的标识符和属性，这使得它们适用于代表数字艺术品、游戏道具等非可替代物品。例如，如果您在以太坊上购买了一张NFT数字艺术品，那么只有您才能拥有这个唯一的代币。

ERC1155代币则是可替代和不可替代的，一个ERC1155代币可以代表一组相同的数字资产，这些资产可以被分割和组合。这使得它们适用于游戏中的道具、虚拟货币等可替代物品。

ERC1155标准与ERC721标准最大的区别是，一个ERC1155合约可以定义多个代币，而ERC721合约只能定义一个。此外，ERC1155代币可以被批量转移，而ERC721代币只能单独转移。

另外，ERC-1159是一种新的标准提案，旨在解决以太坊上代币发行和交易的问题。该标准结合了ERC20和ERC721的优点，可以在同一合约中定义可替代和不可替代的代币，同时还支持代币发行和销毁的燃烧机制。此外，ERC-1159还可以提高代币发行的效率，减少网络拥堵，降低代币交易的成本。



### 11. 简要说明 ERC 1559 作用

ERC-1559是以太坊的一项改进提案，旨在改善以太坊的交易费用机制。当前的以太坊交易费用是由矿工根据交易的竞争情况自由决定的，这可能导致高昂的费用和交易延迟。

ERC-1559提出了一种基于区块空间占用和市场需求的新交易费用机制，其中包括以下要点：

- 每个区块包含的交易数量将被限制在一个预定义的容量范围内，这将导致交易费用的波动性减少。

- 交易费用将由一个算法自动计算，以确保快速确认的交易能够获得更高的优先级。

- 一部分交易费用将被销毁，而不是支付给矿工，这将有助于减少以太坊的通货膨胀。

- 这些改进有望提高以太坊的交易效率，降低交易费用，并减少以太坊的通货膨胀。


### 12. 智能合约钱包中守护恢复是怎么实现的

设置多个地址为守护者，一旦控制合约的 EOA 钱包私钥丢失，就可以由守护者去发起替换合约的 EOA 地址从而达到守护恢复的目的



### 12. 简要说明 EIP4337 作用




### 12. 简要说明 EIP4484 作用





